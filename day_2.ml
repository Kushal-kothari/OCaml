
(* 02/03/2020 *) 

#use "day_1.ml";;
(************************************************************************************)
(* 3. Find the k'th element of a list. (easy) *)
(************************************************************************************)

(* let rec at k, l = match k, l with
	| _ ,[] -> None
	| k, h::t -> if k == 0 then Some h else at (k-1) t *)

let rec at k l = match l with
	| [] -> None
	| h::t -> if k == 1 then Some h else at (k-1) t

(*==================================================================================*)
(* SOLUTIONS *)
(*==================================================================================*)

let rec at_sol k = function
    | [] -> None
    | h :: t -> if k = 1 then Some h else at_sol (k-1) t;;
(* val at : int -> 'a list -> 'a option = <fun> *)
	
(*==================================================================================*)
(* NOTES *)
(*==================================================================================*)

(* function keyword, used for pattern matching of a parameter 
	try to make your function expression as simple as possible, match k is unecessary*)

(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)

(************************************************************************************)
(* 4. Find the number of elements of a list. (easy) *)
(************************************************************************************)

(* recursion *)

let rec length = function 
	| [] -> 0
	| h::t -> 1 + length t

(* tail-recursion *)
let length l =
  let rec length_r acc = function
    | [] -> acc
    | h::t -> length_r (acc+1) t
  in length_r 0 l

(*==================================================================================*)
(* SOLUTION *)
(*==================================================================================*)

(* This function is tail-recursive: it uses a constant amount of
     stack memory regardless of list size. *)
let length_sol list =
  let rec aux n = function
    | [] -> n
    | _::t -> aux (n+1) t
  in aux 0 list;;

(* val length : 'a list -> int = <fun> *)

(*==================================================================================*)
(* NOTES *)
(*==================================================================================*)

(* Finally a perfect one! Good job :D *)

(*==================================================================================*)
(* REVISION *)
(*==================================================================================*)

(* NONE *)
    
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)

(************************************************************************************)
(* 5. Reverse a list. (easy) *)
(************************************************************************************)

let rec rev = function
  | [] ->  []
  | h::t -> (rev t)@[h]

(*==================================================================================*)
(* SOLUTION *)
(*==================================================================================*)

let rev_sol list =
    let rec aux acc = function
      | [] -> acc
      | h::t -> aux (h::acc) t in
    aux [] list 

(*==================================================================================*)
(* NOTES *)
(*==================================================================================*)

(* tail recurion *)

(*==================================================================================*)
(* REVISION *)
(*==================================================================================*)
 
 let rev_rev l = 
  let rec rev_tail acc = function
    | [] -> acc
    | h::t -> rev_tail (h::acc) t
  in  rev_tail [] l
    
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)

(************************************************************************************)
(* 6. Find out whether a list is a palindrome. (easy) *)
(************************************************************************************)
let rec remove = function
  |[]|[_] -> []
  |h::t -> h::(remove t)
 
let rec is_palindrome = function
  | [] | [_] -> true 
  | [x; y] -> x = y 
  | h::t -> if h = (last t) then is_palindrome (remove t) else false

(*==================================================================================*)
(* SOLUTION *)
(*==================================================================================*)
let is_palindrome_sol list =
  list = List.rev list
(* One can use either the rev function from the previous problem, or the
   built-in List.rev *)
(* val is_palindrome : 'a list -> bool = <fun> *)

(*==================================================================================*)
(* NOTES *)
(*==================================================================================*)

(* Use function wrote before but your solution is ok, just long *)

(*==================================================================================*)
(* REVISION *)
(*==================================================================================*)

(* let is_palindrome_rev l = 
  l = rev l *)
    



