
(* 23/02/2015 *)

#use "day_12.ml"

(************************************************************************************)
(* 31. Calculate Euler's totient function Ï†(m). (medium) *)
(************************************************************************************)

let phi n = 
  let rec aux acc x =
    if x = n then acc
  else (if (coprime n x) then aux (acc+1) (x+1) else aux acc (x+1))
in aux 0 1

(*==================================================================================*)
(* SOLUTION *)
(*==================================================================================*)

(* [coprime] is defined in the previous question *)
let phi_sol n =
  let rec count_coprime acc d =
    if d < n then
      count_coprime (if coprime n d then acc + 1 else acc) (d )+ 1
    else acc
  in
  if n = 1 then 1 else count_coprime 0 1
(* val phi : int -> int = <fun> *)
(*==================================================================================*)
(* NOTES *)
(*==================================================================================*)

(* Ignored case phi 1 = 1 at first time, learn from 'count_prime' *)

(*==================================================================================*)
(* REVISION *)
(*==================================================================================*)

let phi n = 
  let rec aux acc x =
    if x = n then acc
  else (if (coprime n x) then aux (acc+1) (x+1) else aux acc (x+1))
in 
if n = 1 then 1 else aux 0 1   
    
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)

(************************************************************************************)
(* 32. Determine the prime factors of a given positive integer. (medium) *)
(************************************************************************************)

let factors n = 
  let rec aux x y =
    if y = 1 then []
    else
      (if is_prime x && (y mod x = 0) then x::(aux x (y/x))
      else aux (x+1) y)
  in aux 1 n

(*==================================================================================*)
(* SOLUTION *)
(*==================================================================================*)

(* Recall that d divides n iff [n mod d = 0] *)
  let factors_sol n =
    let rec aux d n =
      if n = 1 then [] else
        if n mod d = 0 then d :: aux d (n / d) else aux (d+1) n
    in
    aux 2 n;;
(* val factors : int -> int list = <fun> *)

(*==================================================================================*)
(* NOTES *)
(*==================================================================================*)

(* Same idea as solution, solution satrts at 2 becasue it does not have the condition
to check if 1 is prime or not; otehrwise it will loop forever *)

(*==================================================================================*)
(* REVISION *)
(*==================================================================================*)

(* NONE *)
    
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)

(************************************************************************************)
(* 33. Determine the prime factors of a given positive integer (2). (medium) *)
(************************************************************************************)

let factors_2 n = 
  let rec reduce acc counter = function
    | [] -> []
    | [x] -> acc @ [(x, counter+1)]
    | h1::(h2::_ as t) -> if h1 = h2 then reduce acc (counter+1) t
                          else reduce (acc @ [(h1, counter+1)]) 0 t
  in reduce [] 0 (factors n)

(*==================================================================================*)
(* SOLUTION *)
(*==================================================================================*)

let factors_2_sol n =
  let rec aux d n =
    if n = 1 then [] else
      if n mod d = 0 then
        match aux d (n / d) with
        | (h,n) :: t when h = d -> (h,n+1) :: t
        | l -> (d,1) :: l
      else aux (d+1) n
  in
  aux 2 n;;
(* val factors : int -> (int * int) list = <fun> *)

(*==================================================================================*)
(* NOTES *)
(*==================================================================================*)

(* Study the solution *)

(*==================================================================================*)
(* REVISION *)
(*==================================================================================*)

(* NONE *)

    
