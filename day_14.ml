(* 24/02/2020 *)
#load "unix.cma";;
#use "day_13.ml"
open Unix;;


(************************************************************************************)
(* 34. Calculate Euler's totient function Ï†(m) (improved). (medium) *)
(************************************************************************************)

let phi_improved n = 
  let rec pow a p  = 
    if p < 1 then 1 else pow (a*a) (p-1)
  in
  let rec multiply acc = function
   | [] -> acc
   | (a,b)::d -> multiply (acc*(a-1)*(pow a (b-1))) d
 in multiply 1 (factors_2 n)

(*==================================================================================*)
(* SOLUTION *)
(*==================================================================================*)

(* Naive power function. *)
let rec pow n p = if p < 1 then 1 else n * pow n (p-1);;
(* val pow : int -> int -> int = <fun> *)
(* [factors] is defined in the previous question. *)
let phi_improved_sol n =
  let rec aux acc = function
    | [] -> acc
    | (p,m) :: t -> aux ((p - 1) * (pow p (m - 1)) * acc) t in
  aux 1 (factors_2_sol n)
(* val phi_improved : int -> int = <fun> *)

(*==================================================================================*)
(* NOTES *)
(*==================================================================================*)

(* Some logic errors at begining *)

(*==================================================================================*)
(* REVISION *)
(*==================================================================================*)

(* NONE *)
    
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)

(************************************************************************************)
(* 35. Compare the two methods of calculating Euler's totient function. (easy) *)
(************************************************************************************)

let timeit f a =
  let t = Sys.time() in
  ignore(f a);
  let t1 = Sys.time() in
  t1 -. t
    
(*==================================================================================*)
(* SOLUTION *)
(*==================================================================================*)

(* Naive [timeit] function.  It requires the [Unix] module to be loaded. *)
  let timeit_sol f a =
    let t0 = Unix.gettimeofday() in
    ignore(f a);
    let t1 = Unix.gettimeofday() in
    t1 -. t0;;
(* val timeit : ('a -> 'b) -> 'a -> float = <fun> *)

(*==================================================================================*)
(* NOTES *)
(*==================================================================================*)

(* Import module; use different built-in functions *)

(*==================================================================================*)
(* REVISION *)
(*==================================================================================*)

(* NONE *)
    
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)

(************************************************************************************)
(* 36. A list of prime numbers. (easy) *)
(************************************************************************************)

let all_primes a b = 
  let rec aux acc x y = 
    if x = y then acc
  else
      if is_prime_sol x then aux (acc@[x]) (x+1) y
    else aux acc (x+1) y
  in aux [] a b

(*==================================================================================*)
(* SOLUTION *)
(*==================================================================================*)

let is_prime n =
    let n = max n (-n) in
    let rec is_not_divisor d =
      d * d > n || (n mod d <> 0 && is_not_divisor (d+1)) in
    is_not_divisor 2
  
let rec all_primes_sol a b =
  if a > b then [] else
    let rest = all_primes (a + 1) b in
    if is_prime a then a :: rest else rest;;

(* val is_prime : int -> bool = <fun> *)
(* val all_primes : int -> int -> int list = <fun> *)
(*==================================================================================*)
(* NOTES *)
(*==================================================================================*)

(* No need for tail-recursion *)

(*==================================================================================*)
(* REVISION *)
(*==================================================================================*)

(* NONE *)

