(* 06/02/2020 *)

#use "day_4.ml"
(************************************************************************************)
(* 12. Decode a run-length encoded list. (medium) *)
(************************************************************************************)

let rec repeat item = function
  | 0 -> []
  | larger -> item :: (repeat item (larger -1))

let rec decode = function
  |[] -> []
  |h::t -> (begin match h with
      |One x -> x::(decode t)
      |Many (n, x) -> (repeat x n)@(decode t) end)
    
(*==================================================================================*)
(* SOLUTION *)
(*==================================================================================*)

let decode_sol list =
    let rec many acc n x =
      if n = 0 then acc else many (x :: acc) (n-1) x in
    let rec aux acc = function
      | [] -> acc
      | One x :: t -> aux (x :: acc) t
      | Many (n,x) :: t -> aux (many acc n x) t  in
    aux [] (List.rev list);;
(* val decode : 'a rle list -> 'a list = <fun> *)

(*==================================================================================*)
(* NOTES *)
(*==================================================================================*)

(* 1. Try tail recursion*)

(*==================================================================================*)
(* REVISION *)
(*==================================================================================*)

(* NONE *)

    
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)
(*+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-*)

(************************************************************************************)
(* 13. Run-length encoding of a list (direct solution). (medium) *)
(************************************************************************************)


let encode_3 list = 
  let update count x = if count = 0 then One x else Many (count+1, x) in
  let rec help counter acc = function 
    | [] -> []
    | [h] -> acc@ [update (counter+1) h]
    | h1::(h2 ::_ as t) -> if h1 = h2 then help (counter+1) acc t 
                          else help 0 ( acc @ [update (counter+1) h1]) t in 
    (help 0 [] liast)



(*==================================================================================*)
(* SOLUTION *)
(*==================================================================================*)

let encode_3_sol list =
    let rle count x = if count = 0 then One x else Many (count + 1, x) in
    let rec aux count acc = function
      | [] -> [] (* Can only be reached if original list is empty *)
      | [x] -> rle count x :: acc
      | a :: (b :: _ as t) 9if a = b then aux (count + 1) acc t
                              else aux 0 (rle count a :: acc) t  in
    List.rev (aux 0 [] list);;
(* val encode : 'a list -> 'a rle list = <fun> *)

(*==================================================================================*)
(* NOTES *)
(*==================================================================================*)

(* notes *)

(*==================================================================================*)
(* REVISION *)
(*==================================================================================*)

(* NONE *)

